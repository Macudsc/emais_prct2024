// ci_cd/Jenkins/pipeline.jenkinsfile
pipeline {
  agent any
  environment {
    DOCKER_CREDS = 'dockerhub-credentials-id'
    TG_BOT_TOKEN = credentials('telegram-bot-token')
    KUBECONFIG_FILE = '/tmp/kubeconfig' // Путь к kubeconfig на Jenkins-node
    CLOUD_ID = credentials('yandex-cloud-id') // Jenkins credential для cloud_id
    FOLDER_ID = credentials('yandex-folder-id') // Jenkins credential для folder_id
    YC_TOKEN = credentials('yandex-token') // Jenkins credential для токена Яндекса
    MASTER_IP = ""  // Заполнится значением из вывода Terraform
    WORKER_IP = ""  // Заполнится значением из вывода Terraform
  }
  stages {
    stage('Checkout github') {
      steps {
        git branch: 'dev', url: 'https://github.com/Macudsc/emais_prct2024.git'
      }
    }
    stage('Prepare tg bot token') {
      steps {
        sh "echo \"tokenn='${TG_BOT_TOKEN}'\" >> Emais/sensetiv.py"
      }
    }
    //===
    stage('Generate creds.tfvars') {
      steps {
        script {
          // Создание файла creds.tfvars с использованием креденшиалов от дженкинса
          sh """
          echo 'cloud_id  = "${CLOUD_ID}"' > ci_cd/Terraform/creds.tfvars
          echo 'folder_id = "${FOLDER_ID}"' >> ci_cd/Terraform/creds.tfvars
          echo 'token     = "${YC_TOKEN}"' >> ci_cd/Terraform/creds.tfvars
          """
        }
      }
    }
    stage('Generate cloud-config') {
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: 'vm-ssh-key', keyFileVariable: 'SSH_KEY')]) {
          script {
            sh "ls -la ci_cd/Terraform/"

            // Считываем SSH ключ в переменную
            def sshKey = sh(script: "cat ${SSH_KEY}", returnStdout: true).trim()

            // Заменяем ssh_key в cloud-config на реальный SSH ключ
            sh """
              sed 's|{{ ssh_key }}|${sshKey}|' ci_cd/Terraform/cloud-config > ci_cd/Terraform/cloud-config-gen
            """
          }
        }
      }
    }
    stage('Deploy Infrastructure') {
      steps {
        script {
          dir('ci_cd/Terraform') {
            sh 'terraform init'
            sh 'terraform apply -var-file="vars.tfvars" -var-file="creds.tfvars" -auto-approve'
          }
        }
      }
    }
    stage('Fetch VM IPs') {
      steps {
        dir('ci_cd/Terraform') {
          script {
            def vmIps = sh(script: 'terraform output -json ip', returnStdout: true).trim()
            def ipList = readJSON(text: vmIps)
            env.MASTER_IP = ipList['master_ip']
            env.WORKER_IP = ipList['worker_ip']
            echo "Master IP: ${MASTER_IP}, Worker IP: ${WORKER_IP}"
          }
        }
      }
    }
    //===

    stage('Deploy VM Setup') {
      steps {
        withCredentials([sshUserPrivateKey(credentialsId: 'vm-ssh-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
          script {
            ansiblePlaybook(
              playbook: 'ci_cd/Ansible/vm_setup.yml',
              inventory: "${MASTER_IP},${WORKER_IP},",
              extras: "-e ansible_user=${SSH_USER} -e ansible_ssh_private_key_file=${SSH_KEY}"
            )
          }
        }
      }
    }
    stage('Install Kubernetes with Kubespray') {
        steps {
            withCredentials([sshUserPrivateKey(credentialsId: 'vm-ssh-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
                script {
                    ansiblePlaybook(
                      playbook: 'ci_cd/Ansible/kubespray_setup.yml',
                      inventory: "${MASTER_IP},${WORKER_IP},",
                      extras: "-e master_ip=${MASTER_IP} -e worker_ip=${WORKER_IP} -e ansible_user=root -e ansible_ssh_private_key_file=${SSH_KEY}"
                    )
                }
            }
        }
    }
    stage('Fetch and Replace kubeconfig') {
        steps {
            withCredentials([sshUserPrivateKey(credentialsId: 'vm-ssh-key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
                script {
                    sh """
                      scp -i ${SSH_KEY} ${SSH_USER}@${MASTER_IP}:/root/.kube/config /tmp/kubeconfig
                    """
                    sh """
                      sed -i 's|https://127.0.0.1:6443|https://${MASTER_IP}:6443|g' /tmp/kubeconfig
                    """
                }
            }
        }
    }
    stage('Deploy to K8s') {
      steps {
        script {
          sh 'curl -LO "https://storage.googleapis.com/kubernetes-release/release/v1.20.5/bin/linux/amd64/kubectl"'
          sh 'chmod u+x ./kubectl'  
          sh "./kubectl --kubeconfig=${KUBECONFIG_FILE} apply -f ci_cd/K8s/namespace.yml"
          sh "./kubectl --kubeconfig=${KUBECONFIG_FILE} apply -f ci_cd/K8s/postgres-pvc.yml"
          sh "./kubectl --kubeconfig=${KUBECONFIG_FILE} apply -f ci_cd/K8s/postgres-deployment.yml"
          sh "./kubectl --kubeconfig=${KUBECONFIG_FILE} apply -f ci_cd/K8s/mongo-pvc.yml"
          sh "./kubectl --kubeconfig=${KUBECONFIG_FILE} apply -f ci_cd/K8s/mongo-deployment.yml"
          sh "./kubectl --kubeconfig=${KUBECONFIG_FILE} apply -f ci_cd/K8s/app-deployment.yml"
        }
      }
    }

    //stage('Build Docker Image PIPELINE') {
    //  steps {
    //    script {
    //      docker.build('komapolson/emais-app:latest')
    //    }
    //  }
    //}
    //stage('Push Docker Image') {
    //  steps {
    //    script {
    //      withDockerRegistry([credentialsId: DOCKER_CREDS, url: 'https://index.docker.io/v1/']) {
    //        docker.image('komapolson/emais-app:latest').push('latest')
    //      }
    //    }
    //  }
    //}

    //stage('Docker image remove') {
    //  steps {
    //    script {
    //      sh "docker rmi komapolson/emais-app:latest || true"
    //    }
    //  }
    //}
  }
  post {
    always {
      cleanWs()
    }
  }
}
